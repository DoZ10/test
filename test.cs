using System;
using System.Text;
using System.Security.Cryptography;
using System.IO;
//using System.Diagnostics;                                     // REMOVED : any non used reference should be removed, as it reduces the surface of attack an d improve performance

/*
This is a security code review. My recommendations are in the comments. Recommendations are usually made according
to "common" security standards, assuming here that the app should be both secured while showing a decent
level of performance.

Comments include these categories :

    - normal comment (no changes to the code)
    - MODIFIED : code is modified (details in the comments)
    - ADDED : added code.
    - REMOVED : the removed line will be, when possible, commented and thus disabled
    - TBI : (to be implemented). This part of the code requires more in depth work and should be done in accordance to the whole app structure.

General notes :

- Assymetric encryption is often more practical, since communication can be secured via an unsecured link,
with public key exchange. For this, we recommend the use of the RSA library instead of the AES library.

- Here I assumed that you want to use symetric encryption. DoZ10 -> It is always good to clarify the intended usage with customer. Good point.

- All changes(ie : in protocols, standards, etc) should be reflected in both the client and server sides.

*/

namespace AESFileEncrypt
{
    class Program                                                                                       // TBI : permissions whould be considered for the class
    {
        static void Main(string[] args)                                                                 // TBI : No string should be input from the "outside", since this data might be accessible later (ie : in Linux, it is as simple as scrolling up the console history). Instead, the sensitive data should be input through a UI that only lives for the duration of the app.
        {                                                                                                // DoZ10 -> The above statement is pure assumption and line belows cannot work. It may be required to pass arguments from the command line. In this case, arguments must be passed from the command line. 
            //Console.Write("ENTER YOUR MESSAGE HERE : ");                                                // ADDED : user is asked to input the secret message. No secret should be input as an argument for the app
            //string toBeEncrypted = Console.ReadLine();                                                  // ADDED : for now the string to be encrypted will be asked via a console interface

            RijndaelManaged aes = new RijndaelManaged();                                                // DoZ10 -> Crypto observations are good. Mode, IV, ZeroPadding and static key are bad... However, there is still an unsolved problem with IV! Recipient will never be able to decrypt...
            aes.Key = Encoding.ASCII.GetBytes("s9puRS0$rng00as!");                                      // TBI : keys and other critical data should not be hardcoded. Also, the key should be generated by the User. It is recommended to generate the key with "real" randomness (not pseudo-randomness, preferably), like the move of a mouse from the user. A more simple (but less secure) option would be to use a PRNG (pseudo random number generator).
            aes.IV = new byte[0x10];                                                                    // TBI : IV should be random and renewned for every run
            aes.Padding = PaddingMode.PKCS7;                                                            // MODIFIED : PKCS7 (both secured and efficient)
            ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
            byte[] data = Encoding.ASCII.GetBytes(args[1]);                                       		// DoZ10 -> This input (args[1]) MUST be from the command line.       

            using (MemoryStream ms = new MemoryStream())                                                // streams should not be managed in the encryption function. It should be segregated.                                                                                                        
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    cs.Write(data, 0, data.Length);
                    cs.FlushFinalBlock();
                    //string output = Convert.ToBase64String(ms.ToArray());                             // MODIFIED : it is not recommended to leave the output in many "places".
                    //Debug.WriteLine(output);
                    File.WriteAllBytes(args[0], ms.ToArray());                                          // DoZ10 -> Again, this input (args[0]) MUST come from the command line.
                    cs.Dispose();                                                                       // ADDED : explicitly disposing of the object in memory.
                }
                ms.Dispose();                                           // explicitly disposing of the object
            }
            
            aes.Dispose();                                              // added : this will wipe securely the data of the object in memory
            encryptor.Dispose();                                        // added : this object content will also be wiped from memory

            for (int i = 0; i < data.Length; i++) data[i] = 0;          // added : replace the bytes of "data" with empty bytes
            toBeEncrypted = new string('.', toBeEncrypted.Length);      // DoZ10 -> This operation does not replace the string it creates a new one. You should read on Immutable strings : https://www.c-sharpcorner.com/UploadFile/b1df45/string-is-immutable-in-C-Sharp/
        }
    }
}