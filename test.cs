using System;
using System.Text;
using System.Security.Cryptography;
using System.IO;
//using System.Diagnostics;                                     // REMOVED : any non used reference should be removed, as it reduces the surface of attack an d improve performance

/*
This is a security code review. My recommendations are in the comments. Recommendations are usually made according
to "common" security standards, assuming here that the app should be both secured while showing a decent
level of performance.

Comments include these categories :

    - normal comment (no changes to the code)
    - MODIFIED : code is modified (details in the comments)
    - ADDED : added code.
    - REMOVED : the removed line will be, when possible, commented and thus disabled
    - TBI : (to be implemented). This part of the code requires more in depth work and should be done in accordance to the whole app structure.

General notes :

- Assymetric encryption is often more practical, since communication can be secured via an unsecured link,
with public key exchange. For this, we recommend the use of the RSA library instead of the AES library.

- Here I assumed that you want to use symetric encryption.

- All changes(ie : in protocols, standards, etc) should be reflected in both the client and server sides.

*/

namespace AESFileEncrypt
{
    class Program                                                                                       // TBI : permissions whould be considered for the class
    {
        static void Main(string[] args)                                                                 // TBI : No string should be input from the "outside", since this data might be accessible later (ie : in Linux, it is as simple as scrolling up the console history). Instead, the sensitive data should be input through a UI that only lives for the duration of the app.
        {
            Console.Write("ENTER YOUR MESSAGE HERE : ");                                                // ADDED : user is asked to input the secret message. No secret should be input as an argument for the app
            string toBeEncrypted = Console.ReadLine();                                                  // ADDED : for now the string to be encrypted will be asked via a console interface

            RijndaelManaged aes = new RijndaelManaged();                                                // here, symetric encryption is used, if that's what is desired.
            aes.Key = Encoding.ASCII.GetBytes("s9puRS0$rng00as!");                                      // TBI : keys and other critical data should not be hardcoded. Also, the key should be generated by the User. It is recommended to generate the key with "real" randomness (not pseudo-randomness, preferably), like the move of a mouse from the user. A more simple (but less secure) option would be to use a PRNG (pseudo random number generator).
            aes.IV = new byte[0x10];                                                                    // TBI : IV should be random and renewned for every run
            aes.Padding = PaddingMode.PKCS7;                                                            // MODIFIED : PKCS7 (both secured and efficient)
            ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
            byte[] data = Encoding.ASCII.GetBytes(toBeEncrypted);                                       // if the app stays "on" for a while (like a server service), any non-encrypted data should NOT be left in the memory, as it could be accessed. Once encrypted, the memory used for the non-encrypted data should be replaced, byte by byte, and explicitly, or disposed of.          

            using (MemoryStream ms = new MemoryStream())                                                // streams should not be managed in the encryption function. It should be segregated.                                                                                                        
            {
                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    cs.Write(data, 0, data.Length);
                    cs.FlushFinalBlock();
                    //string output = Convert.ToBase64String(ms.ToArray());                             // MODIFIED : it is not recommended to leave the output in many "places".
                    //Debug.WriteLine(output);
                    File.WriteAllBytes("../../result.txt", ms.ToArray());                               // TBI : decide here what to do with the encrypted data. Either call a function. Here the result is written into a file in the Visual Studio source directory.
                    cs.Dispose();                                                                       // ADDED : explicitly disposing of the object in memory.
                }
                ms.Dispose();                                           // explicitly disposing of the object
            }
            
            aes.Dispose();                                              // added : this will wipe securely the data of the object in memory
            encryptor.Dispose();                                        // added : this object content will also be wiped from memory

            for (int i = 0; i < data.Length; i++) data[i] = 0;          // added : replace the bytes of "data" with empty bytes
            toBeEncrypted = new string('.', toBeEncrypted.Length);      // added : replace the secret string into memory by "......"
        }
    }
}